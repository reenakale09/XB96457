# -*- coding: utf-8 -*-
"""Classwork 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BjGLQ3EZq0iMfCxFklpULI99gDZqXi6Z
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import CategoricalNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report

try:
    file_path = "https://raw.githubusercontent.com/UB01976/is7332025/refs/heads/main/data-mining-project-repo/03032025_CW/hamspam.csv"
    jt_1 = pd.read_csv(file_path)
except FileNotFoundError:
    print("Error: The file 'hamspam.csv' was not found. Make sure it's in the correct directory, or specify the full path.")
    exit()

jt_1['Contains Link'] = jt_1['Contains Link'].map({'Yes': 1, 'No': 0})
jt_1['Contains Money Words'] = jt_1['Contains Money Words'].map({'Yes': 1, 'No': 0})
jt_1['Length'] = jt_1['Length'].map({'Long': 1, 'Short': 0})
jt_1['Class'] = jt_1['Class'].map({'Spam': 1, 'Ham': 0})  # Spam is positive class (1), Ham is negative (0)

X = jt_1[['Contains Link', 'Contains Money Words', 'Length']]
y = jt_1['Class']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

nb_model = CategoricalNB()
nb_model.fit(X_train, y_train)
nb_predictions = nb_model.predict(X_test)
nb_accuracy = accuracy_score(y_test, nb_predictions)
print("Naive Bayes Accuracy:", nb_accuracy)
print("Naive Bayes Classification Report:\n", classification_report(y_test, nb_predictions))

knn_model = KNeighborsClassifier(n_neighbors=2)
knn_model.fit(X_train, y_train)
knn_predictions = knn_model.predict(X_test)
knn_accuracy = accuracy_score(y_test, knn_predictions)
print("\nKNN Accuracy:", knn_accuracy)
print("KNN Classification Report:\n", classification_report(y_test, knn_predictions))

import pandas as pd

# Load data from the provided URL
file_path = "https://raw.githubusercontent.com/UB01976/is7332025/refs/heads/main/data-mining-project-repo/03032025_CW/roc_data.csv"
jt_1 = pd.read_csv(file_path)

# Define thresholds to evaluate
thresholds = [0.95, 0.90, 0.85, 0.80, 0.75, 0.70]

# Calculate the total number of true positive and true negative cases
total_positives = sum(jt_1["True_Label"] == 1)
total_negatives = sum(jt_1["True_Label"] == 0)

# List to store results for each threshold
results = []

# Loop through each threshold to calculate TP, FP, TN, FN, TPR, and FPR
for threshold in thresholds:
    jt_1["Predicted_Label"] = (jt_1["Prediction"] >= threshold).astype(int)

    TP = sum((jt_1["Predicted_Label"] == 1) & (jt_1["True_Label"] == 1))
    FP = sum((jt_1["Predicted_Label"] == 1) & (jt_1["True_Label"] == 0))
    TN = sum((jt_1["Predicted_Label"] == 0) & (jt_1["True_Label"] == 0))
    FN = sum((jt_1["Predicted_Label"] == 0) & (jt_1["True_Label"] == 1))

    TPR = TP / total_positives if total_positives > 0 else 0
    FPR = FP / total_negatives if total_negatives > 0 else 0

    # Print results for each threshold
    total_count = TP + FP + TN + FN
    print(f"Threshold: {threshold} -> TP: {TP}, FP: {FP}, TN: {TN}, FN: {FN}, Total: {total_count}")

    # Append results to the results list
    results.append([threshold, TP, FP, TN, FN, TPR, FPR])

# Create a DataFrame from the results list to display it neatly
roc_table = pd.DataFrame(results, columns=["Threshold", "TP", "FP", "TN", "FN", "TPR", "FPR"])

# Print the complete ROC table
print(roc_table)

import pandas as pd
import matplotlib.pyplot as plt

# Load data from the provided URL
file_path = "https://raw.githubusercontent.com/UB01976/is7332025/refs/heads/main/data-mining-project-repo/03032025_CW/roc_data.csv"
jt_1 = pd.read_csv(file_path)

# Define thresholds to evaluate
thresholds = [0.95, 0.90, 0.85, 0.80, 0.75, 0.70]

# Lists to store True Positive Rate (TPR) and False Positive Rate (FPR)
tpr_values = []
fpr_values = []

# Calculate the total number of true positive and true negative cases
total_positives = sum(jt_1["True_Label"] == 1)
total_negatives = sum(jt_1["True_Label"] == 0)

# Loop through each threshold to calculate TPR and FPR
for threshold in thresholds:
    jt_1["Predicted_Label"] = (jt_1["Prediction"] >= threshold).astype(int)

    TP = sum((jt_1["Predicted_Label"] == 1) & (jt_1["True_Label"] == 1))
    FP = sum((jt_1["Predicted_Label"] == 1) & (jt_1["True_Label"] == 0))

    TPR = TP / total_positives if total_positives > 0 else 0
    FPR = FP / total_negatives if total_negatives > 0 else 0

    tpr_values.append(TPR)
    fpr_values.append(FPR)

# Create the ROC curve plot
plt.figure(figsize=(6, 6))
plt.plot(fpr_values, tpr_values, marker='o', linestyle='-', color='b', label='ROC Curve')
plt.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Random Classifier')
plt.xlabel("False Positive Rate (FPR)")
plt.ylabel("True Positive Rate (TPR)")
plt.title("ROC Curve")
plt.legend()
plt.grid(True)
plt.savefig("roc_curve_2a.png")  # Save the ROC curve to a file
plt.show()

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import CategoricalNB
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Load data from the provided URL
file_path = "https://raw.githubusercontent.com/UB01976/is7332025/refs/heads/main/data-mining-project-repo/03032025_CW/hamspam.csv"
pb = pd.read_csv(file_path, index_col='ID')

# Encode categorical variables using Label Encoder
le = LabelEncoder()
pb['Contains Link'] = le.fit_transform(pb['Contains Link'])
pb['Contains Money Words'] = le.fit_transform(pb['Contains Money Words'])
pb['Length'] = le.fit_transform(pb['Length'])
pb['Class'] = le.fit_transform(pb['Class'])

# Split features and target
X = pb[['Contains Link', 'Contains Money Words', 'Length']]
y = pb['Class']

# Split into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and fit the Naive Bayes model
nb_model = CategoricalNB()
nb_model.fit(X_train, y_train)

# Predict probabilities for the positive class
y_pred_proba = nb_model.predict_proba(X_test)[:, 1]

# Calculate ROC curve and AUC score
fpr, tpr, _ = roc_curve(y_test, y_pred_proba)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.savefig("roc_curve_2b.png")  # Save the ROC curve as an image file
plt.show()

# Print the AUC score
print(f"AUC Score: {roc_auc:.4f}")